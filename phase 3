Baseline_equiv_fn<-function(MatchedSets,Treatvar,ID_vars,pre_pooled_sd,Match_num="Match_num",SD_mean_before=NULL,ref_var=NULL,other_psm=NULL,plot.points=T,outlier_dist=3,global=T){
  '%notin%'<-Negate('%in%')
  options(useFancyQuotes = F)
  if(global){
    suppressPackageStartupMessages(require(openxlsx))
    suppressPackageStartupMessages(require(data.table))
    suppressPackageStartupMessages(require(lattice))
    suppressPackageStartupMessages(require(latticeExtra))
    suppressPackageStartupMessages(require(gridExtra))
    suppressPackageStartupMessages(require(maptools))
    suppressPackageStartupMessages(require(DescTools))
  } else {
    require(openxlsx)
    require(data.table)
    require(lattice)
    require(latticeExtra)
    require(gridExtra)
    require(maptools)
    require(DescTools)
  }
  
  ll<-lapply(as.list(match.call(expand.dots = F))[c("Treatvar","ID_vars")],as.name)
  dataname<-pairlist_converter(as.list(match.call())$MatchedSets)
  
  ######Shaping pre-pooled SDs in format necessary for this function###################
  if(is.null(names(pre_pooled_sd))|(class(pre_pooled_sd)[match("data.frame",class(pre_pooled_sd))]!="data.frame"&class(pre_pooled_sd)[match("list",class(pre_pooled_sd))]!="list"&class(pre_pooled_sd)[match("numeric",class(pre_pooled_sd))]!="numeric")){
    stop(paste("You need to enter a valid Pooled SD measure. This can be either a list, dataframe, or named number object with pooled standard deviations based on the full sample corresponding to the names of the covariates used in the matching process. Length of pooled SD column or vector must be equal to the number of covariates in your",sQuote(ll$MatchedSets),"not including",paste(ll$Treatvar,ll$ID_vars,"or",Match_num,sep=",")))
  }
  
  if(is.data.frame(pre_pooled_sd)){
    if(length(pre_pooled_sd)==2){
      num_col<-which(sapply(pre_pooled_sd,is.numeric))
      char_col<-which(sapply(pre_pooled_sd,function(i) class(i)!="numeric"))
      pooled_format<-setnames(data.table(pre_pooled_sd),c(char_col,num_col),c("Covariates","Pooled_SD"))[,Covariates:=as.character(Covariates)]
    } else{
      pooled_format<-data.table(setNames(data.frame(t(pre_pooled_sd)),"Pooled_SD"),keep.rownames = "Covariates")[,Covariates:=as.character(Covariates)]
    }
  } else{
    pooled_format<-listrep2datatable_fn(as.list(pre_pooled_sd),left_varname = "Covariates",right_varname = "Pooled_SD")[,Covariates:=as.character(Covariates)]
  }
  
  ##Control flow for whether to present before and after SMD and also as a check for same variables in Matched Sets and pre-pooled_SDs#######
  
  if(!is.null(ref_var)&&!is.null(SD_mean_before)){
    X<-ref_var[data.table(MatchedSets),on=c(ID_vars,Treatvar)][,c(pooled_format$Covariates,Treatvar,other_psm,Match_num,ID_vars),with=F]
    Compare_ind<-T
  } else if(is.null(ref_var)&&!is.null(SD_mean_before)){
    X<-data.table(MatchedSets)[,c(pooled_format$Covariates,Treatvar,other_psm,Match_num,ID_vars),with=F]
    Compare_ind<-T
  } else {
    Compare_ind<-F
    if(length(which(pooled_format$Covariates%notin%colnames(MatchedSets)))!=0){
      stop(paste(paste(pooled_format$Covariates[which(pooled_format$Covariates%notin%colnames(MatchedSets))],collapse = ","),"are not in",sQuote(dataname)))
    } else {
      X<-data.table(MatchedSets)[,c(pooled_format$Covariates,Treatvar,other_psm,Match_num,ID_vars),with=F]
      print("No before and after comparison is possible based on your specified options. If you wish to produce a before and after matching comparison specify a dataframe in the function options for the standardized means before matching.")
    }
  }
  
  ####Verifying the correct treatment group
  
  if(is.numeric(MatchedSets[[Treatvar]])){
    print(paste(sQuote(match.call()$Treatvar),"is not a factor.  Assuming",sQuote(max(X[[Treatvar]])),"is the treatment group."))
    X[,eval(Treatvar):=car::recode(eval(ll$Treatvar),paste0(min(X[[Treatvar]]),"='Comparison';",max(X[[Treatvar]]),"='Treatment'"))]
  } else{
    X[,eval(Treatvar):=lapply(.SD,factor),.SDcols=Treatvar]
  }
  Match_weights_means<-dcast(suppressWarnings(melt(copy(X)[,-c(ID_vars),with=F],id.vars=c(Treatvar,Match_num),variable.factor=F)),as.formula(paste(paste0(c(Treatvar,Match_num),collapse="+"),"~","variable")),fun=list(N=length,Weighted=mean))
  
  Match_weights<-dcast(suppressWarnings(melt(dcast(setnames(copy(Match_weights_means)[,c(1:3),with=F],3,"Match_num_wts")[,ATT_wts:=ifelse(eval(ll$Treatvar)=="Treatment",1,1/Match_num_wts)],paste0("Match_num","~",Treatvar),value.var=c("Match_num_wts","ATT_wts"))[,ATT_wts_Comparison:=Match_num_wts_Treatment*ATT_wts_Comparison],id.vars=c("Match_num"),variable.factor=F))[,eval(Treatvar):=factor(gsub("Match_num_wts_|ATT_wts_","",variable))][,variable:=gsub("_Comparison|_Treatment","",variable)],paste0("Match_num+",Treatvar,"~variable"))
  
  #print(colnames(Match_weights_means))
  colnames(Match_weights_means)[grep("value_",colnames(Match_weights_means))]<-gsub("value_","",grep("value_",colnames(Match_weights_means),value=T))
  Match_means<-copy(Match_weights_means)[,c(Match_num,Treatvar,grep("Weighted",colnames(Match_weights_means),value = T)),with=F]
  Weighted_covariates<-unique(copy(Match_weights)[copy(Match_means),on=c(Match_num,Treatvar)][copy(X),on=c(Match_num,Treatvar)][,ID_count:=.N,by=ID_vars][ID_count>1,ATT_wts:=as.numeric(ID_count)][,-c("ID_count"),with=F],by=ID_vars)###Used for assigning wts with Nearest w/ replacement to upweight comparison
  
  Weighted_covariates_graph<-copy(Match_weights)[copy(Match_means),on=c(Match_num,Treatvar)]
  
  colnames(Weighted_covariates_graph)[grep("Weighted.",colnames(Weighted_covariates_graph))]<-gsub("Weighted.","",grep("Weighted.",colnames(Weighted_covariates_graph),value=T))
  
  Group_means_sds<-dcast(melt(Reduce(function(...) merge(...),setattr(lapply(colnames(Weighted_covariates_graph)[-match(c(Treatvar,Match_num,"Match_num_wts","ATT_wts"),colnames(Weighted_covariates_graph))],function(j) setkeyv(Weighted_covariates_graph[is.na(Weighted_covariates_graph[[j]])==F,lapply(.SD,function(i) list(Mean=mean(i,na.rm=T),SD=sd(i,na.rm=T))),by=Treatvar,.SDcols=j][,Stat:=rep(c("Mean","SD"),length(unique((Weighted_covariates_graph[[Treatvar]]))))],c(Treatvar,"Stat"))),"names",colnames(Weighted_covariates_graph)[-match(c(Treatvar,Match_num,"Match_num_wts","ATT_wts"),colnames(Weighted_covariates_graph))]))[,lapply(copy(.SD),unlist)],id.vars=c(Treatvar,"Stat"),variable.name="Covariates",variable.factor=F),paste0("Covariates~Stat+",Treatvar))
  
  
  Match_mean_diff<-listrep2datatable_fn(as.list(copy(Weighted_covariates_graph)[,-c(Match_num,"Match_num_wts","ATT_wts"),with=F][,lapply(copy(.SD),mean),by=Treatvar][,sapply(copy(.SD),function(i) abs(diff(unlist(i)))),.SDcols=-c(Treatvar)]),left_varname = "Covariates",right_varname = "Raw_Bias")
  
  cat_vars<-Binary_indication_fn(X)
  
  SD_list<-rbind(Group_means_sds[Covariates%notin%cat_vars,grep("^SD_|Covariates",colnames(Group_means_sds)),with=F],Group_means_sds[Covariates%in%cat_vars,c("Covariates","Mean_Comparison","Mean_Treatment"),with=F][,c("SD_Comparison","SD_Treatment"):=lapply(.SD,function(i) sqrt(i*(1-i))),.SDcols=c("Mean_Comparison","Mean_Treatment")][,-c("Mean_Comparison","Mean_Treatment"),with=F])##Need to sqrt this to make consistent with continuous formula. SD vs variance for binomials.
  final_results<-SD_list[Match_mean_diff,on="Covariates"][pooled_format,on="Covariates"][,SD_Bias:=Raw_Bias/Pooled_SD]
  
  PSM_var<-grep("psm",pooled_format$Covariates,value = T)
  
  if(length(PSM_var)==0){
    if(is.null(other_psm)){
      print("Unable to detect psm variable. Please specify by including the variable name as a character vector in 'other_psm' parameter of function for psm analysis if you wish to get more analysis for it.")
    } else {
      PSM_var=other_psm
    }
  }
  
  ll_up<-append(ll,list(PSM_var=as.name(PSM_var),Match_num=as.name(Match_num)))
  
  if(!is.null(PSM_var)){
    PSM_summary<-PSM_graph_data<-copy(Weighted_covariates_graph)[is.na(eval(ll_up$PSM_var))==F][,PSM_Dist:=abs(diff(eval(ll_up$PSM_var))),by=Match_num][,list(N=.N,Mean=mean(PSM_Dist,na.rm=T),SD=sd(PSM_Dist,na.rm=T),Median=median(PSM_Dist,na.rm=T),Range=(paste0(format(round(range(PSM_Dist,na.rm=T),4),nsmall = 4),collapse = "-")))]
    
    
    ###########Graphing############
    
    plotcolors<-c("cyan","magenta")
    
    PSM_graph_data<-copy(Weighted_covariates_graph)[is.na(eval(ll_up$PSM_var))==F][,Dist:=diff(eval(ll_up$PSM_var)),by=Match_num][,Direction:=ifelse(Dist>=0,"Positive","Negative")]
    
    
    PSM_graph_data_match<-dcast(copy(PSM_graph_data),paste(paste0(c(Match_num,"Dist","Direction"),collapse = "+"),"~",Treatvar),value.var=PSM_var)[,Outlier:=ifelse(abs(Dist)>=outlier_dist*sd(Dist),"Outlier","Under3SD")]
    
    OL_dist=abs(PSM_graph_data_match$Dist[PSM_graph_data_match$Outlier=="Outlier"])
    
    Dist_SD<-sd(abs(PSM_graph_data_match$Dist))
    
    if(length(OL_dist)>0&length(OL_dist)<=50){
      DistGraphScaleTicks=seq(0,eval(max(OL_dist)+Dist_SD),by=Dist_SD/4)
    } else if(length(OL_dist)>50){
      warning(paste("Number of outliers",outlier_dist,"standard deviations away from the mean exceeded 50 which obscures the auto-generated visual. This could imply poor matches. Please specify larger 'outlier_dist' to be able to view the outlier visual and possibly consider using a different matching technique and/or specification."),call. = F)
      DistGraphScaleTicks<-NULL
    } else{
      DistGraphScaleTicks<-NULL
      print(paste("No 'outliers' greater than",outlier_dist,"were detected so outlier plot was not generated."))
    }
    
    PSM_hist_after<-histogram(as.formula(paste("~",PSM_var,"|",Treatvar)),data=Weighted_covariates_graph,group=eval(ll$Treatvar),type="count",main=paste("Predicted PSM Scores by",sQuote(ll$Treatvar)),xlab=c("PSM Scores"),col=plotcolors,strip=strip.custom(bg="lightgrey",par.strip.text=list(cex=0.7,fontface="bold")),scales=list(alternating=F,tck=c(1,0)),panel=function(x,col=col,...){
      panel.histogram(x,col=col[packet.number()],...)
    })
    
    PSM_dens_after<-densityplot(as.formula(paste("~",PSM_var)),data=PSM_graph_data,group = eval(ll$Treatvar),auto.key = list(border=T,background="lightgrey",fontface="bold",cex=0.7,corner=c(1,1)),main=paste("Density Plot of Predicted PSM Scores by",sQuote(ll$Treatvar)),xlab=c("PSM Scores"),scales = list(tck=c(1,0)),plot.points=plot.points)
    
    grid.arrange(PSM_hist_after,PSM_dens_after,ncol=1)
    
    RightMarginKey<-list(title=expression(paste(underline(bold("Distance Direction")))),space="right",columns=1,border=F,fontface="bold",cex=0.7,cex.title=0.7)
    
    UpperMarginKey<-list(title=expression(paste(bold("Distance Direction"))),space="top",columns=2,border=T,background="lightgrey",fontface="bold",cex=0.7,cex.title=0.8)
    
    
    Matched_dist_comparisons<-xyplot(as.formula(paste(sort(levels(PSM_graph_data[[Treatvar]]),decreasing = T),collapse = "~")),data=PSM_graph_data_match,group=Direction,pch=21,cex=1,col=plotcolors,main=paste("PSM Score by Matched Pair "),auto.key=RightMarginKey,scales=list(tck=c(1,0)),xlim=c(0,1),ylim=c(0,1),aspect="iso",panel=function(x,y,...){
      panel.xyplot(x,y,...)
      panel.abline(a=0,b=1,col="black")
    })
    
    if(!is.null(DistGraphScaleTicks)){
      Matched_dist_comparisons<-update(Matched_dist_comparisons,main="PSM Score by Matched Pair with Labeled Outliers")+as.layer(xyplot(as.formula(paste(sort(levels(PSM_graph_data[[Treatvar]]),decreasing = T),collapse = "~")),data=copy(PSM_graph_data_match)[Outlier=="Outlier"],group=Direction,pch=21,cex=1,col=plotcolors,panel=function(x,y,data=copy(PSM_graph_data_match)[Outlier=="Outlier"],...){
        panel.xyplot(x,y,...)
        panel.pointLabel(x=x,y=y,labels=data$Match_num,cex=0.5)
        panel.abline(a=0,b=1,col="black")
      }),under=F)
      
      Outlier_only<-xyplot(as.formula(paste(sort(levels(PSM_graph_data[[Treatvar]]),decreasing = T),collapse = "~")),data=copy(PSM_graph_data_match)[Outlier=="Outlier"],group=Direction,pch=21,cex=1,col=plotcolors,auto.key=RightMarginKey,main=paste0("Matched Pairs of PSM Scores for Outliers Only (",outlier_dist," SDs)"),scales=list(tck=c(1,0)),at=NULL,panel=function(x,y,data=copy(PSM_graph_data_match)[Outlier=="Outlier"],...){
        panel.xyplot(x,y,...)
        panel.text(x=1,y=1,labels=paste("y=x"))
        panel.pointLabel(x=x,y=y,labels=data$Match_num,cex=0.8,fontface = "bold")
        panel.abline(a=0,b=1,col="red")
      })
      
      Outlier_dist<-xyplot(as.formula(paste(c(substitute(abs(Dist)),Match_num),collapse="~")),data=copy(PSM_graph_data_match)[Outlier=="Outlier"],group=Direction,type=c("p"),pch=21,cex=1,col=plotcolors,auto.key=RightMarginKey,main=paste0("Absolute PSM Score Distance for Outliers (",outlier_dist," SDs)"," of Matched Units"),xlab="Match Numbers",ylab="PSM Score Distance",ylim=c(0,eval(max(OL_dist)+Dist_SD)),scales=list(x=list(draw=F),y=list(relation="same",tck=c(1,0))),panel=function(x,y,data=copy(PSM_graph_data_match)[Outlier=="Outlier"],...){
        panel.xyplot(x,y,...)
        panel.pointLabel(x=x,y=y,labels=data$Match_num,cex=0.8,fontface = "bold")
      })
      
      grid.arrange(Matched_dist_comparisons,Outlier_dist,ncol=1,heights=c(2,1))
    } else{
      Outlier_only=NULL
      print(Matched_dist_comparisons)
    }
  } else{
    Matched_dist_comparisons=NULL
  }
  ##This ends the psm analysis.
  
  ######This is for printing global sets and control flow for PBR analysis and Comparison of SD Bias of before and after####
  #print(paste("This is the SD_mean_before class: ",class(SD_mean_before)))
  if("Balance"%in%class(SD_mean_before)){
    Comparison_obj<-SD_mean_before[copy(final_results)[,c("Covariates","SD_Bias"),with=F],on="Covariates"][,PBR:=100*(SD_Bias-i.SD_Bias)/SD_Bias][,c("SD_Bias","i.SD_Bias","PBR"):=lapply(.SD,function(i) format(round(i,4),nsmall=4)),.SDcols=c("SD_Bias","i.SD_Bias","PBR")]
    print(setnames(Comparison_obj,c("Covariates","SD_Bias_before","SD_Bias_after","PBR")))
  }
  #,c("Covariates","SD_means_before_matching","SD_means_after_matching")
  if(global){
    dataname<-as.character(dataname)
    
    assign(paste(dataname,"with_weights",sep="_"),Weighted_covariates,envir = .GlobalEnv)
    assign(paste("Desc_stats",dataname,sep="_"),Group_means_sds,envir = .GlobalEnv)
    
    assign(paste("SDmeans",dataname,sep="_"),copy(final_results)[,c("Covariates","SD_Bias"),with=F],envir = .GlobalEnv)
    
    assign(paste("Compare",dataname,sep="_"),tryCatch(Comparison_obj,error=function(e) {
      warning("Unable to generate a before and after matching comparison of standardized mean differences because you did not provide that option. Either create manually or provide one as created in the PSM_diagnostic function.",call. = F)
      NULL
    }),envir = .GlobalEnv)
  }
  
  if(Compare_ind){
    cat("\n\tSummary of Propensity Score Differences Between Matches\n-----------------------------------------------------------------------------\n")
    print(PSM_summary)
    
    return(list(Full_data_wts=Weighted_covariates,
                Matched_data_wts=Weighted_covariates_graph,
                Descriptive_stats_wts=Group_means_sds,
                All_calc=final_results[,colnames(final_results)[-match("Covariates",colnames(final_results))]:=lapply(.SD,function(i) round(i,4)),.SDcols=colnames(final_results)[-match("Covariates",colnames(final_results))]],
                Compare=tryCatch(Comparison_obj,error=function(e) NULL),
                  #setnames(SD_mean_before[copy(final_results)[,c("Covariates","SD_Bias"),with=F],on="Covariates"],c("Covariates","SD_means_before_matching","SD_means_after_matching")),error=function(e) NULL),
                PSM_summary=PSM_summary,
                All_PSMmatches=Matched_dist_comparisons,
                Outliers_only=Outlier_only,
                PSM_Hist=PSM_hist_after))
  } else {
    
    cat("\n\tSummary of Propensity Score Differences Between Matches\n-----------------------------------------------------------------------------\n")
    print(PSM_summary)
    
    return(list(Full_data_wts=Weighted_covariates,
                Matched_data_wts=Weighted_covariates_graph,
                Descriptive_stats_wts=Group_means_sds,
                All_calc=final_results[,colnames(final_results)[-match("Covariates",colnames(final_results))]:=lapply(.SD,function(i) round(i,4)),.SDcols=colnames(final_results)[-match("Covariates",colnames(final_results))]],SD_means=final_results[,c("Covariates","SD_Bias"),with=F],
                PSM_summary=PSM_summary,
                All_PSMmatches=Matched_dist_comparisons,
                Outliers_only=Outlier_only,
                PSM_Hist=PSM_hist_after))
  }
}


Optimal_match_fn<-function(Matchingcovs_PSM,Treatvar,ID_vars,ratio=1,fitted_glm=T,glm_family="binomial",glmweights=NULL,other_fitted_model=NULL,custom_dist=NULL,Match_type=c("both","Pair","Full"),exact_vars=NULL,include_exact_psm=F,caliper=NULL,Caliper_vars=NULL,Caliper_glm=T,dist_method=c("euclidean","mahalanobis","rank_mahalanobis","custom"),standardization.scale=sd,min.controls = 0, max.controls = Inf,omit.fraction=NULL,global=T,verbose=T){
  
  if(global){
    suppressPackageStartupMessages(require(optmatch))
  } else require(optmatch)
  
  dataframe_name<-pairlist_converter(as.list(match.call())$Matchingcovs_PSM)
  
  X<-suppressWarnings(data.table(eval(Matchingcovs_PSM))[,-c("Inverse_weight"),with=F])
  ll_calls<-as.list(match.call(expand.dots = F))
  ll<-lapply(ll_calls[c("Treatvar","ID_vars")],as.name)
  
  ###Processing Treatment variable by converting it to factor and then assigning numeric values (1 for treatment, 0 for comparison)
  if(verbose){
    if(is.numeric(X[[Treatvar]])){
      print(paste(sQuote(match.call()$Treatvar),"is not of class factor.  Assuming",sQuote(max(X[[Treatvar]])),"is the treatment group."))
    } else if(is.character(X[[Treatvar]])){
      print(paste(sQuote(match.call()$Treatvar),"is not of class factor.  Assuming",sQuote(sort(unique(X[[Treatvar]]))[length(unique(X[[Treatvar]]))]),"is the treatment category based on alphanumeric order. If this is incorrect either convert class to a factor specifying proper treatment variable or recode the treatment variable such that the treatment code is the highest alphanumeric value."))
    } else {
      print(paste(sQuote(match.call()$Treatvar),"is of class factor and assuming",sQuote(levels(X[[Treatvar]])[nlevels(X[[Treatvar]])]),"is the treatment group."))
    }
  }
  
  X[[Treatvar]]<-cat2facNum_converter_fn(X[[Treatvar]],verbose=F)##Converted to factor
  
  orig_treat_levels<-setNames(levels(X[[Treatvar]]),c("Comparison","Treatment"))##Link between original levels and comparison and treatment.
  X<-copy(X)[,eval(Treatvar):=as.numeric(eval(ll$Treatvar))-1]
  
  X_optmatch<-suppressWarnings(X[,-c("psmscore"),with=F])
  
  #Match_on syntax
  ##1. This nested switch statament allows for all valid classes of "x" for match_on.
  if(is.null(other_fitted_model)){
    glm_method<-switch(dist_method[1],
                       "euclidean"={
                         if(!include_exact_psm){
                           substitute(glm(paste(eval(Treatvar),"~",paste0(colnames(X_optmatch)[-match(c(Treatvar,ID_vars,exact_vars),colnames(X_optmatch))],collapse = "+")),data=X_optmatch,family=glm_family,weights=glmweights))
                         } else {
                           substitute(glm(as.formula(paste(Treatvar,"~",paste0(colnames(X_optmatch)[-match(c(Treatvar,ID_vars),colnames(X_optmatch))],collapse = "+"))),data=X_optmatch,family=glm_family,weights=glmweights))
                         }
                       },
                       "mahalanobis"={
                         as.formula(paste(Treatvar,"~",paste0(colnames(X_optmatch)[-match(c(ID_vars,exact_vars,Treatvar),colnames(X_optmatch))],collapse="+")))
                       },
                       "rank_mahalanobis"={
                         as.formula(paste(Treatvar,"~",paste0(colnames(X_optmatch)[-match(c(ID_vars,exact_vars,Treatvar),colnames(X_optmatch))],collapse="+")))
                       },
                       "custom"={
                         if(!is.null(custom_dist)){
                           list(x=setNames(X_optmatch[[custom_dist]],X_optmatch[[ID_vars]]),z=X_optmatch[[Treatvar]])
                         }
                         else {
                           stop(paste0("Entering custom implies you created your own distance measure outside this function and attached that measure to your data set.  Please include the name of this variable in ",dataframe_name,"."))
                         }
                       },
                       
                       stop("You need to specifiy a valid dist-method in the function call!"))
  } else {
    glm_method<-other_fitted_model
  }
  
  ##2. Creates caliper specification
  if(!is.null(Caliper_vars)){
    if(Caliper_glm){
      Caliper_glm_model<-substitute(glm(paste(Treatvar,"~",paste0(Caliper_vars,collapse = "+")),data=X_optmatch,family=glm_family,weights=glmweights))
      
      Caliper_model<-suppressWarnings(caliper(eval(match_on(eval(Caliper_glm_model),data=X_optmatch,standardization.scale=standardization.scale)),width = caliper))
    } else{
      Caliper_model<-caliper(match_on(as.formula(paste(Treatvar,"~",paste0(Caliper_vars,collapse = "+"))),data=X_optmatch),width = caliper)}##Possibly add an else statement for mahalanobis all vars
  }
  
  ##3. Creates exact matches
  if(!is.null(exact_vars)){
    Within_model<-as.formula(paste(Treatvar,"~",paste0(exact_vars,collapse="+")))
  }
  ####This switch combines all possible forms of syntax options for the match_on matrix which will then be passed onto pair match or full match.
  exact_cal_var_ind<-as.character(interaction(is.null(exact_vars),is.null(Caliper_vars)))
  match_on_matrix<-switch(exact_cal_var_ind,
                          "TRUE.TRUE"={
                            if(is.null(custom_dist)) {
                              match_on(eval(glm_method),data=X_optmatch,caliper=caliper,standardization.scale=standardization.scale)
                            } else{
                              match_on(x=glm_method$x,data=X_optmatch,z=glm_method$z,caliper=caliper,standardization.scale=standardization.scale)
                            }
                          },
                          "TRUE.FALSE"={
                            if(is.null(custom_dist)) {
                              match_on(eval(glm_method),data=X_optmatch,standardization.scale=standardization.scale)+Caliper_model
                            } else {
                              match_on(x=glm_method$x,data=X_optmatch,z=glm_method$z,standardization.scale=standardization.scale)+Caliper_model}
                          },
                          "FALSE.TRUE"={
                            if(is.null(custom_dist)) {
                              match_on(eval(glm_method),data=X_optmatch,within = exactMatch(Within_model,data=X_optmatch),caliper=caliper,standardization.scale=standardization.scale)
                            } else {
                              match_on(x=glm_method$x,data=X_optmatch,z=glm_method$z,within = exactMatch(Within_model,data=X_optmatch),caliper=caliper,standardization.scale=standardization.scale)
                            }
                          },
                          "FALSE.FALSE"={
                            if(is.null(custom_dist)) {
                              match_on(eval(glm_method),data=X_optmatch,within=exactMatch(Within_model,data=X_optmatch),standardization.scale=standardization.scale)+Caliper_model
                            } else {
                              match_on(x=glm_method$x,data=X_optmatch,z=glm_method$z,within = exactMatch(Within_model,data=X_optmatch),standardization.scale=standardization.scale)+Caliper_model
                            }
                          })
  
  matches<-switch(Match_type[1],
                  "both"={
                    list(Full=full(match_on_matrix,data=X_optmatch,min.controls=min.controls,max.controls=max.controls,omit.fraction=omit.fraction),Pair=pair(match_on_matrix,controls=ratio,data=X_optmatch))
                  },
                  "Pair"={
                    list(Pair=pair(match_on_matrix,controls = ratio,data=X_optmatch))
                  },
                  "Full"={
                    list(Full=full(match_on_matrix,data=X_optmatch,min.controls=min.controls,max.controls=max.controls,omit.fraction=omit.fraction))
                  },
                  stop("Must enter a valid type of matching!"))
  
  final_matches_all<-tryCatch(
    {
      lapply(matches,function(i) data.table(data.frame(X,Match_num=as.numeric(plyr::mapvalues(i,levels(i),1:nlevels(i))),Match_status=matched(i)))[,eval(Treatvar):=factor(eval(ll$Treatvar),labels = c("Comparison","Treatment"))])
    },error=function(e) 1)
  
  final_matches<-tryCatch(lapply(final_matches_all,function(i) i[Match_status==T]),error = function(e) NULL)
  Unmatched_treat<-lapply(final_matches_all,function(i) tryCatch(i[Match_status==F&eval(ll$Treatvar)=="Treatment",ID_vars,with=F],error=function(e) NULL))
  Failed_matches<-matches
  
  #Printing quick summary to console
  lapply(seq_along(final_matches),function(i) print(paste(nrow(Unmatched_treat[[i]]),"treatment subjects removed and",length(unique(final_matches[[i]][[ID_vars]])),"total unique subjects in the",names(final_matches)[i],"matched set.")))
  
  if(global){
    basenames<-tryCatch(lapply(seq_along(final_matches),function(i) paste(names(final_matches)[i],as.character(dataframe_name),sep="_")),error=function(e) NULL)
    if(!is.null(final_matches)){
      if(exists(basenames[[1]],envir = .GlobalEnv)){
        basenames<-Global_name_gen(names(final_matches),dataframe_name)
      }
    }
    
    if(!is.null(final_matches)){
      lapply(seq_along(final_matches),function(i){
        assign(basenames[[i]],final_matches[[i]],envir = .GlobalEnv)
      })
    }
    
  }
  
  return(list(Matched_sets=final_matches,UnmatchedIDs=Unmatched_treat))
}

StatsDT_fn<-function(X,groupvars,outcome_vars=NULL,ID=NULL,stat_col=T,group_col=T,varcol=T,nlevels_cont=10,round_digit=2,percents=T,verbose=T){
  require(data.table)
  '%notin%'<-Negate('%in%')
  if(verbose){
    print(paste("Assuming",sQuote(groupvars[1]),"is the treatment variable. If not please re-enter your grouping variables with the treatment variable as the first variable."))
  }
  
  if(group_col!=F){
    if(length(groupvars)>1){
      ll<-list(groupvars=unlist(strsplit(gsub("^c|[[:punct:]]","",deparse(match.call()$"groupvars")),split = " ")))
      mult_group_vars=T
      if(group_col==T){
        stop("You entered multiple grouping variables an indicated you wanted them in columns so you need to specify which of them to include in columns. Re-run the function by replacing the 'T' in 'group_col' with a character vector of variable names or 'A' if you want all of them in columns.")
      }
      if(group_col=="A") {group_col<-groupvars}
    } else {mult_group_vars=F}
  } else {mult_group_vars=F} #This is case where group_col=F which overrides the multiple variables in groupvars since they won't be printed in columns anyway.
  #This changes value in group_col to name of the single group variable in groupvars for consistency later.
  if(group_col==T&mult_group_vars==F){
    ll<-lapply(as.list(match.call())["groupvars"],as.name)
    group_col<-groupvars
  }
  
  #Creates X without ID variable and identifies outcome variables
  if(is.null(outcome_vars)){
    if(is.null(ID)){
      outcome_vars<-colnames(X)[-match(groupvars,colnames(X))]
    } else {
      outcome_vars<-colnames(X)[-match(c(groupvars,ID),colnames(X))]
      
      X<-X[,-ID,with=F]
      if(.Platform$OS.type=="unix"){
        
        if(sys.nframe()>1){
          orig_id<-orig_call_fn(match.call()$ID)
        } else {
          orig_id<-match.call()$ID
        }
        if(verbose){
          print(paste("Assuming ID variable is", sQuote(orig_id),"and removing it from descriptive statistics."))
        }
      }##Closes operating system indicator
    }##Closes ID detector loop
  } else{
    if(!is.null(ID)){ X<-X[,-ID,with=F]}
  }
  X<-X[,c(groupvars,outcome_vars),with=F]
  #Identifying which variables are continuous for adding percents later.
  continuous_vars<-names(which(sapply(X,function(i) length(unique(i))>nlevels_cont)==T))
  #Checking for missing values in groupvars and recoding them to unknown as necessary
  grouplist_test<-copy(X)[,groupvars,with=F]
  invisible(lapply(seq_along(grouplist_test),function(i) if(sum(is.na(grouplist_test[[i]]))>1){
    if(verbose){
      print(paste("WARNING:",groupvars[i],"has",sum(is.na(grouplist_test[[i]])), "missing values. Coding them to Unknown."))
    }
    X[,groupvars[i]:=lapply(.SD,function(x) as.character(ifelse(is.na(X[[x]]),"Unknown",X[[x]]))),.SDcols=groupvars[i]]
  }))
  ##Calculating stats by interacting the group variables
  grouplist<-lapply(groupvars,function(i) as.character(X[[i]]))
  Mod_X<-copy(X)[,Group:=interaction(grouplist)]
  
  results_list<-setattr(lapply(outcome_vars,function(j) Mod_X[is.na(Mod_X[[j]])==F,lapply(.SD,function(i) list(N=.N,Mean=format(round(mean(i,na.rm=T),round_digit),nsmall=round_digit),SD=format(round(sd(i,na.rm=T),round_digit),nsmall=round_digit))),by=groupvars,.SDcols=j][,Stat:=rep(c("N","Mean","SD"),length(unique(interaction(grouplist))))]),"names",outcome_vars)
  
  raw_results<-Reduce(function(...) merge(...,by=c(groupvars,"Stat"),all=T), results_list)[,lapply(.SD,as.character)][,Stat:=factor(Stat,levels = c("N","Mean","SD"))]
  if(percents==T){
    percent_cols<-colnames(raw_results)[-match(c(groupvars,"Stat",continuous_vars),colnames(raw_results))]
    raw_results<-copy(raw_results)[Stat=="Mean",eval(percent_cols):=lapply(.SD,function(i) paste0(as.character(round(as.numeric(i)*100,0)),"%")),.SDcols=eval(percent_cols)]
  }
  ####Creating the casting layout for final results starting with whether there are multiple grouping variables and then whether user wants a variable column or if they should be spread in a wide format.
  stat_var_ind<-interaction(varcol,stat_col)
  recast<-NULL
  #Group_col can only take on False and char string
  if(group_col==F){
    switch(as.character(stat_var_ind),
           "TRUE.TRUE"={
             dcast_formula<-paste("variable","+","Stat","~",paste0(groupvars,collapse = "+"))},
           "TRUE.FALSE"={
             dcast_formula<-paste("variable","~",paste0(c("Stat",groupvars),collapse = "+"))},
           "FALSE.TRUE"={
             dcast_formula<-paste("Stat","~",paste0(c("variable",groupvars),collapse = "+"))},
           {stop("Need at least one column")})
  } else {
    switch(as.character(stat_var_ind),
           "FALSE.FALSE"={
             dcast_formula<-paste(paste0(group_col,collapse="+"),"~",paste0(c("variable","Stat",groupvars[-match(groupvars,group_col)]),collapse = "+"))},
           "TRUE.FALSE"={
             dcast_formula<-paste(paste0(c("variable",group_col),collapse="+"),"~",paste0(c("Stat",groupvars[-match(groupvars,group_col)]),collapse = "+"))},
           "FALSE.TRUE"={
             dcast_formula<-paste(paste0(c(group_col,"Stat"),collapse="+"),"~",paste0(c("variable",groupvars[-match(groupvars,group_col)]),collapse = "+"))},
           {recast=F})
  }
  if(is.null(recast)){
    final_results<-dcast(melt(raw_results,id.vars=c(groupvars,"Stat"),variable.factor=F),dcast_formula)
  } else {
    final_results<-melt(raw_results,id.vars=c(groupvars,"Stat"),variable.factor=F)
  }
  return(final_results)
}


predict.MCMC<- function(MCMCfit, pred_data, type="mean"){
  pred_vars<- rbind(t(rep(1,nrow(pred_data))),pred_data[,colnames(MCMCfit)[-1],with=F][,transpose(.SD)])
  predict.p.mcmc <-  1 / (1 + exp(-MCMCfit %*% data.matrix(pred_vars)))
  #interval.p.mcmc <- function(x, low, high) apply(predict.p.mcmc(x), 2,
  #function(x) quantile(x, c(low, high)))
  final_output<- switch(type,
                        "mean"= {
                          data.table(predict.p.mcmc)[,sapply(.SD,mean)]
                        })
  return(final_output)
  
}
Nearest_Match_fn<-function(Matchingcovs_PSM,Treatvar,ID_vars,include.psm=F,distance="glm",custom_dist=F,matching_model="glm",family="binomial",weights=NULL,ratio=1,m.order="random",caliper=NULL,exact_vars=NULL,ties=T,distance.tolerance=1e-05,global=T,...){
  '%notin%'<-Negate('%in%')
  require(data.table)
  dataframe_name<-pairlist_converter(as.list(match.call())$Matchingcovs_PSM)
  X_psm<-suppressWarnings(data.table(eval(Matchingcovs_PSM))[,-c("Inverse_weight"),with=F])
  if(sum(sapply(X_psm,function(i) sum(is.na(i))))){stop("You need to remove missing values first.  Use SD_mean_before function to run diagnostics and remove missing values.")}
  
  #Checking for numeric data
  if(sum(sapply(copy(X_psm)[,-c(Treatvar,ID_vars),with=F],is.numeric)==F)!=0){stop(paste("You need to change",paste(sQuote(names(which(sapply(copy(X_psm)[,-c(Treatvar,ID_vars),with=F],is.numeric)==F))),collapse=","),"to numeric data first!"))}
  
  ll<-lapply(as.list(match.call(expand.dots = F))[c("Treatvar","ID_vars")],as.name)
  ##Checking if the psmvariable is attached to dataframe
  if(include.psm==F){
    X<-suppressWarnings(copy(X_psm)[,-c("psmscore"),with=F])
  } else {X<-copy(X_psm)}
  Treatvar_class<-class(X[[Treatvar]])
  X[[Treatvar]]<-switch(Treatvar_class,
                        "factor"={print(paste0(sQuote(ll$Treatvar)," is a factor. Assigning 0 to ",sQuote(levels(X[[Treatvar]])[1])," and 1 to ",sQuote(levels(X[[Treatvar]])[2]),". If this is incorrect assign higher level of ",sQuote(ll$Treatvar)," to the treatment and rerun."));as.numeric(X[[Treatvar]])-1
                        },
                        "numeric"={print(paste0(sQuote(ll$Treatvar)," is numeric. Assigning 0 to ",sQuote(min(X[[Treatvar]]))," and 1 to ",sQuote(max(X[[Treatvar]])),". If this is incorrect assign higher value of ",sQuote(ll$Treatvar)," to the treatment and rerun."));plyr::mapvalues(X[[Treatvar]],sort(unique(X[[Treatvar]])),c(0,1))
                        },
                        "character"={tmp_fac<-factor(ll$Treatvar);print(paste0(sQuote(X[[Treatvar]])," is a character vector. Assigning 0 to ",sQuote(levels(tmp_fac)[1])," and 1 to ",sQuote(levels(tmp_fac)[2]),". If this is incorrect convert ",sQuote(ll$Treatvar)," to a factor or numeric variable and rerun."));as.numeric(tmp_fac)-1
                        },
                        stop(print(paste("Cannot match on",sQuote(ll$Treatvar),"because it is not a factor or numeric vector.  Check to see if you assigned correct variable to",sQuote("Treatvar"))))
  )
  if(custom_dist==F){
    if(xtabs(paste("~",Treatvar),data = X)[1]<xtabs(paste("~",Treatvar),data=X)[2]&m.order=="random"){
      print("Fewer control than treated units preventing default random matching order. Nearest Neighbor without Replacement will match Treatment units in the order of largest to smallest. Specify 'smallest' in m.order option if you wish to change the matching behavior or add a caliper to prevent potential poor matches.")
      m.order="largest"
    }
    
    ##GLM to pass to matchit or optmatch
    if(is.null(caliper)){caliper=0}
    matchit_formula<-as.formula(paste(eval(Treatvar),"~.",paste0("-(",c(ID_vars,exact_vars),")")))
    Matching_nearest_results<- switch(distance,
                             "glm"={
                               suppressWarnings(lapply(lapply(c(TRUE,FALSE),function(i) MatchIt::matchit(matchit_formula,data=X,distance= distance,ratio=ratio,m.order=m.order,caliper=caliper,exact=exact_vars,replace=i)),"[","match.matrix"))
                               },
                             "mahalanobis"={
                               if(caliper== 0){
                                 suppressWarnings(lapply(lapply(c(TRUE,FALSE),function(i) MatchIt::matchit(matchit_formula,data=X,distance= distance,ratio=ratio,m.order=m.order,caliper=NULL,exact=exact_vars,replace=i)),"[","match.matrix"))
                               }else{
                                 pred_var<- setdiff(colnames(X),c(ID_vars,exact_vars,Treatvar))
                                 mahal_formula<-as.formula(paste("~",paste0(pred_var,collapse = "+")))
                                 suppressWarnings(lapply(lapply(c(TRUE,FALSE),function(i) MatchIt::matchit(matchit_formula,data=X,distance= matching_model,ratio=ratio,m.order=m.order,caliper=caliper,
                                                                                          mahvars =mahal_formula, exact=exact_vars,replace=i)),"[","match.matrix"))
                               }
                             },
                             "MCMC"={
                               mcmc_fit<- MCMClogit(matchit_formula,data = X)
                               mcmc_ps<- predict.MCMC(mcmc_fit,X)
                               suppressWarnings(lapply(lapply(c(TRUE,FALSE),function(i) MatchIt::matchit(matchit_formula,data=X,distance=mcmc_ps ,ratio=ratio,m.order=m.order,caliper=caliper,
                                                                                                         exact=exact_vars,replace=i)),"[","match.matrix"))
                               },{})
    
    #if(matching_model=="glm"){
      #matchit_formula<-as.formula(paste(eval(Treatvar),"~.",paste0("-(",c(ID_vars,exact_vars),")")))
      #matching_model<-suppressWarnings(substitute(glm(glm_call,data=X,family = family)))
      #matching_model<-substitute(glm(paste(eval(Treatvar),"~.",paste0("-(",c(ID_vars,exact_vars),")")),data=X,family = family,weights=weights))
    #} else matching_model<-substitute(matching_model)
    #print(matching_model)
    #Matching_nearest_results<-suppressWarnings(lapply(lapply(c(TRUE,FALSE),function(i) MatchIt::matchit(matchit_formula,data=X,distance= distance,ratio=ratio,m.order=m.order,caliper=caliper,exact=exact_vars,replace=i)),"[","match.matrix"))
    
    All_match_results<-lapply(setattr(Matching_nearest_results,"names",c("Nearest_with_replacement","Nearest_without_replacement")),function(i) data.table(setNames(data.frame(i),paste0(rep("Comparison",ratio),c(1:ratio))),keep.rownames = "Treat"))
    
    Matched_sets<-lapply(All_match_results,function(i) melt(copy(i)[,colnames(i):=lapply(.SD,function(j) eval(X[[ID_vars]])[match(j,attr(X,"row.names"))]),.SDcols=colnames(i)][,Match_num:=1:.N],id.vars="Match_num",variable.name=Treatvar,value.name=ID_vars)[,Match_num:=as.numeric(Match_num)])
    
    Unmatched_treatment<-lapply(Matched_sets,function(i) copy(i)[Match_num%in%copy(i)[is.na(eval(ll$ID_vars))]$Match_num][eval(ll$Treatvar)=="Treat"][,c(ID_vars,"Match_num"),with=F])
    Function_ind<-"MatchIt"
  } else{
    Function_ind<-"Matching"
    if(distance%in%colnames(X)){
      Matching_nearest_results<-setattr(lapply(c(TRUE,FALSE), function(i) Matching::Match(Tr=X[[Treatvar]],X=X[[distance]],M=ratio,ties = ties,weights=weights,caliper = caliper,distance.tolerance = distance.tolerance,replace=i)),"names",c("Nearest_with_replacement","Nearest_without_replacement"))
      
      Matched_sets<-lapply(Matching_nearest_results,function(i) unique(melt(data.table(data.frame(i[match(c("index.treated","index.control"),names(i))]))[,Match_num:=rep(seq_along(rle(index.treated)$lengths),rle(index.treated)$lengths)],id.vars="Match_num"),by=c("Match_num","value"))[,-c("variable"),with=F])
      
      Unmatched_treatment<-lapply(Matching_nearest_results,function(i) unname(unlist(copy(X)[i[["index.dropped"]],ID_vars,with=F])))
    } else {stop(paste0("Name of your 'custom distance' must appear in " ,sQuote(dataframe_name)))}
  }
  if(Function_ind=="MatchIt"){
    Final_matched_sets<-setattr(lapply(seq_along(Matched_sets),function(i) copy(X_psm)[eval(copy(Matched_sets[[i]])[,-c(Treatvar),with=F]),on=ID_vars][Match_num%notin%Unmatched_treatment[[i]]$Match_num]),"names",names(Matched_sets))
    print("Matching conducted using the 'MatchIt' package.")
  } else {
    Final_matched_sets<-setattr(lapply(seq_along(Matched_sets),function(i) copy(X)[,value:=as.numeric(row.names(.SD))][Matched_sets[[i]],on="value"][,-c("value"),with=F]),"names",names(Matched_sets))
    print("Matching conducted using the 'Matching' package.")
  }
  if(is.null(exact_vars)){
    exact_data<-suppressWarnings(copy(X)[,-c(Treatvar,distance,ID_vars),with=F])
    exact_patterns<-unique(exact_data,by=colnames(exact_data))[,Match_num:=.I]
    exact_data_IDs<-copy(X)[,ROWID:=.I][,c("ROWID",ID_vars),with=F]
    Exact_all_test<-suppressWarnings(tryCatch(Matching::Match(Tr=X[[Treatvar]],X=exact_data,exact = T,caliper=NULL),error=function(e) 1))
    if(is.list(Exact_all_test)){
      Exact_all<-rbindlist(lapply(c("index.control","index.treated"),function(i) setnames(data.table(data.frame(Exact_all_test[[i]])),"ROWID")))
      Final_matched_sets<-append(Final_matched_sets,list(Exact=unique(exact_patterns[eval(copy(X)[exact_data_IDs,on=ID_vars][Exact_all,on="ROWID"][,-c("ROWID"),with=F]),on=colnames(exact_data)],by=ID_vars)))
      Unmatched_treatment<-append(Unmatched_treatment,list(data.table(data.frame(ID=unname(unlist(copy(X)[Exact_all_test[["index.dropped"]],ID_vars,with=F]))))))
      names(Unmatched_treatment)[3]<-"Exact"
    }
  }
  
  if(global){
    basenames<-lapply(seq_along(Final_matched_sets),function(i) paste(names(Final_matched_sets)[i],as.character(dataframe_name),sep="_"))
    if(exists(basenames[[1]],envir = .GlobalEnv)){
      basenames<-Global_name_gen(names(Final_matched_sets),dataframe_name)
    }
    lapply(seq_along(Final_matched_sets),function(i){
      assign(basenames[[i]],Final_matched_sets[[i]],envir = .GlobalEnv)
    })
  }
  
  ###Printing quick summary to console
  lapply(seq_along(Final_matched_sets),function(i) print(paste(nrow(Unmatched_treatment[[i]]),"treatment subjects removed and",nrow(unique(copy(Final_matched_sets[[i]]),by=ID_vars)),"total unique subjects in the",names(Final_matched_sets)[i],"matched set.")))
  return(list(Matched_Sets=Final_matched_sets,Unmatched_IDs=Unmatched_treatment,Raw_function_output=Matching_nearest_results))
}
